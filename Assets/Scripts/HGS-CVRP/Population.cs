using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Unity.VisualScripting;
using UnityEngine;
using Random = UnityEngine.Random;

public class Population : MonoBehaviour
{
    List<HGSCVRPIndividual> feasibleSubpop;               // Feasible subpopulation, kept ordered by increasing penalized cost
    List<HGSCVRPIndividual> infeasibleSubpop;             // Infeasible subpopulation, kept ordered by increasing penalized cost
    List<bool> listFeasibilityLoad;        // Load feasibility of recent individuals generated by LS
    List<bool> listFeasibilityDuration;    // Duration feasibility of recent individuals generated by LS
    //std::vector<std::pair<clock_t, double>> searchProgress; // Keeps tracks of the time stamps of successive best solutions
    HGSCVRPIndividual bestSolutionRestart;              // Best solution found during the current restart of the algorithm
    HGSCVRPIndividual bestSolutionOverall;              // Best solution found during the complete execution of the algorithm

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    void generatePopulation()
    {
	    if (Parameters.inst.verbose) Debug.Log("----- BUILDING INITIAL POPULATION");
	    for (int i = 0; i< 4* Parameters.inst.ap.mu /*&& (i == 0 || Parameters.inst.ap.timeLimit == 0 || (double) (clock() - Parameters.inst.startTime) / (double) CLOCKS_PER_SEC< Parameters.inst.ap.timeLimit)*/; i++)
	    {
            HGSCVRPIndividual randomIndiv = new HGSCVRPIndividual();
            Split.inst.generalSplit(randomIndiv, Parameters.inst.nbVehicles);
		    localSearch.run(randomIndiv, Parameters.inst.penaltyCapacity, Parameters.inst.penaltyDuration);
		    addIndividual(randomIndiv, true);
		    if (!randomIndiv.eval.isFeasible && Random.Range(0,2) % 2 == 0)  // Repair half of the solutions in case of infeasibility
		    {
			    localSearch.run(randomIndiv, Parameters.inst.penaltyCapacity*10, Parameters.inst.penaltyDuration*10);
			    if (randomIndiv.eval.isFeasible) addIndividual(randomIndiv, false);
            }
        }
    }

    bool addIndividual(HGSCVRPIndividual indiv, bool updateFeasible)
    {
        if (updateFeasible)
        {
            listFeasibilityLoad.Add(indiv.eval.capacityExcess < 0.00001);
            listFeasibilityDuration.Add(indiv.eval.durationExcess < 0.00001);
            listFeasibilityLoad.RemoveAt(0);
            listFeasibilityDuration.RemoveAt(0);
        }

        // Find the adequate subpopulation in relation to the individual feasibility
        List<HGSCVRPIndividual> subpop = (indiv.eval.isFeasible) ? feasibleSubpop : infeasibleSubpop;

        // Create a copy of the individual and updade the proximity structures calculating inter-individual distances
        HGSCVRPIndividual myIndividual = new HGSCVRPIndividual(indiv);
        foreach (HGSCVRPIndividual myIndividual2 in subpop)
        {
            float myDistance = brokenPairsDistance(myIndividual, myIndividual2);
            myIndividual2.indivsPerProximity.Add(Tuple.Create(myDistance, myIndividual));
            myIndividual.indivsPerProximity.Add(Tuple.Create(myDistance, myIndividual2));
        }

        // Identify the correct location in the subpopulation and insert the individual
        int place = subpop.Count;
        while (place > 0 && subpop[place - 1].eval.penalizedCost > indiv.eval.penalizedCost - 0.00001) place--;
        subpop.Insert(place, myIndividual);

        // Trigger a survivor selection if the maximimum subpopulation size is exceeded
        if (subpop.Count > Parameters.inst.ap.mu + Parameters.inst.ap.lambda)
		while (subpop.Count > Parameters.inst.ap.mu)
			removeWorstBiasedFitness(subpop);

        // Track best solution
        if (indiv.eval.isFeasible && indiv.eval.penalizedCost < bestSolutionRestart.eval.penalizedCost - 0.00001)
        {
            bestSolutionRestart = indiv; // Copy
            if (indiv.eval.penalizedCost < bestSolutionOverall.eval.penalizedCost - 0.00001)
            {
                bestSolutionOverall = indiv;
                //searchProgress.push_back({ clock() - Parameters.inst.startTime , bestSolutionOverall.eval.penalizedCost });
            }
            return true;
        }
        else
            return false;
    }

    void updateBiasedFitnesses(List<HGSCVRPIndividual> pop)
    {
        // Ranking the individuals based on their diversity contribution (decreasing order of distance)
        List<Tuple<float, int>> ranking = new List<Tuple<float, int>>();
        for (int i = 0; i < pop.Count; i++)
            ranking.Add(Tuple.Create(-averageBrokenPairsDistanceClosest(pop[i], Parameters.inst.ap.nbClose), i));
        ranking.Sort();

        // Updating the biased fitness values
        if (pop.Count == 1)
            pop[0].biasedFitness = 0;
        else
        {
            for (int i = 0; i < pop.Count; i++)
            {
                float divRank = (float)i / (float)(pop.Count - 1); // Ranking from 0 to 1
                float fitRank = (float)ranking[i].Item2 / (float)(pop.Count - 1);
                if (pop.Count <= Parameters.inst.ap.nbElite) // Elite individuals cannot be smaller than population size
				pop[ranking[i].Item2].biasedFitness = fitRank;

            else
                pop[ranking[i].Item2].biasedFitness = fitRank + (1.0f - (float)Parameters.inst.ap.nbElite / (float)pop.Count) * divRank;
        }
    }
}

    void removeWorstBiasedFitness(List<HGSCVRPIndividual> pop)
    {
        updateBiasedFitnesses(pop);
        if (pop.Count <= 1) throw new InvalidOperationException("Eliminating the best individual: this should not occur in HGS");

        HGSCVRPIndividual worstIndividual = null; ;
        int worstIndividualPosition = -1;
        bool isWorstIndividualClone = false;
        float worstIndividualBiasedFitness = -1e30f;
        for (int i = 1; i < pop.Count; i++)
        {
            bool isClone = (averageBrokenPairsDistanceClosest(pop[i], 1) < 0.00001); // A distance equal to 0 indicates that a clone exists
            if ((isClone && !isWorstIndividualClone) || (isClone == isWorstIndividualClone && pop[i].biasedFitness > worstIndividualBiasedFitness))
            {
                worstIndividualBiasedFitness = pop[i].biasedFitness;
                isWorstIndividualClone = isClone;
                worstIndividualPosition = i;
                worstIndividual = pop[i];
            }
        }

        // Removing the individual from the population and freeing memory
        pop.RemoveAt(worstIndividualPosition);

        // Cleaning its distances from the other individuals in the population
        foreach (HGSCVRPIndividual indiv2 in pop)
        {
            var match = indiv2.indivsPerProximity
                              .FirstOrDefault(pair => pair.Item2 == worstIndividual);

            if (!match.Equals(default((float, HGSCVRPIndividual))))
            {
                indiv2.indivsPerProximity.Remove(match);
            }
        }
    }
    float brokenPairsDistance(HGSCVRPIndividual indiv1, HGSCVRPIndividual indiv2)
    {
	    int differences = 0;
	    for (int j = 1; j <= Parameters.inst.nbClients; j++)
	    {
		    if (indiv1.successors[j] != indiv2.successors[j] && indiv1.successors[j] != indiv2.predecessors[j]) differences++;
		    if (indiv1.predecessors[j] == 0 && indiv2.predecessors[j] != 0 && indiv2.successors[j] != 0) differences++;
	    }
        return (float)differences / (float)Parameters.inst.nbClients;
    }

    float averageBrokenPairsDistanceClosest(HGSCVRPIndividual indiv, int nbClosest)
    {
        float result = 0;
        int maxSize = Mathf.Min(nbClosest, indiv.indivsPerProximity.TotalCount());

        int i = 0;
        foreach (var pair in indiv.indivsPerProximity)
        {
            if (i >= maxSize) break;
            result += pair.Item1;
            i++;
        }

        return maxSize > 0 ? result / maxSize : 0;
    }
}
