using System;
using System.Collections;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;
using Color = UnityEngine.Color;

public class PopulationMgr : MonoBehaviour
{
    public static PopulationMgr inst;

    public List<Individual> feasibleSubpop;            // Feasible subpopulation, kept ordered by increasing penalized cost
    public List<Individual> infeasibleSubpop;          // Infeasible subpopulation, kept ordered by increasing penalized cost
    public List<bool> listFeasibilityLoad;             // Load feasibility of recent individuals generated by LS
    public List<bool> listFeasibilityDuration;         // Duration feasibility of recent individuals generated by LS
    List<Tuple<float, double>> searchProgress;   // Keeps tracks of the time stamps of successive best solutions
    Individual bestSolutionRestart;             // Best solution found during the current restart of the algorithm
    Individual bestSolutionOverall;             // Best solution found during the complete execution of the algorithm

    private void Awake()
    {
        inst = this;
    }

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        if(Input.GetKeyDown(KeyCode.Space))
        {
            foreach(List<int> route in bestSolutionOverall.chromR)
                Debug.Log(BasicsChecking.PrintList(route));
        }
    }

    public void GeneratePopulation()
    {
        Debug.Log("----- BUILDING INITIAL POPULATION");
        for(int i = 0; i < 4*ParametersMgr.inst.ap.mu && 
            (i == 0 || ParametersMgr.inst.ap.timeLimit == 0 || Time.realtimeSinceStartup - ParametersMgr.inst.startTime < ParametersMgr.inst.ap.timeLimit); i++)
        {
            Individual randomIndiv = new Individual();
            SplitMgr.inst.GeneralSplit(randomIndiv, ParametersMgr.inst.nbVehicles);
            LocalSearchMgr.inst.Run(randomIndiv, ParametersMgr.inst.penaltyCapacity, ParametersMgr.inst.penaltyDuration); // Repair half of the solutions in case of infeasibility
            AddIndividual(randomIndiv, true);
            if(!randomIndiv.eval.isFeasible && ParametersMgr.inst.ran.LCG() % 2 == 0)
            {
                LocalSearchMgr.inst.Run(randomIndiv, ParametersMgr.inst.penaltyCapacity*10, ParametersMgr.inst.penaltyDuration*10);
                if (randomIndiv.eval.isFeasible) AddIndividual(randomIndiv, false);
            }
        }
    }

    public bool AddIndividual(Individual indiv, bool updateFeasible)
    {
        if (updateFeasible)
        {
            listFeasibilityLoad.Add(indiv.eval.capacityExcess < 0.00001f);
            listFeasibilityDuration.Add(indiv.eval.durationExcess < 0.00001f);
            listFeasibilityLoad.RemoveAt(0);
            listFeasibilityDuration.RemoveAt(0);
        }

        // Find the adequate subpopulation in relation to the individual feasibility
        List<Individual> subpop = indiv.eval.isFeasible ? feasibleSubpop : infeasibleSubpop;

        // Create a copy of the individual and updade the proximity structures calculating inter-individual distances
        Individual myIndividual = new Individual(indiv);
        foreach (Individual myIndividual2 in subpop)
        {
            float myDistance = BrokenPairsDistance(myIndividual, myIndividual2);

            if (!myIndividual2.indivsPerProximity.ContainsKey(myDistance))
                myIndividual2.indivsPerProximity[myDistance] = new List<Individual>();
            myIndividual2.indivsPerProximity[myDistance].Add(myIndividual);

            if (!myIndividual.indivsPerProximity.ContainsKey(myDistance))
                myIndividual.indivsPerProximity[myDistance] = new List<Individual>();
            myIndividual.indivsPerProximity[myDistance].Add(myIndividual2);
        }

        // Identify the correct location in the subpopulation and insert the individual
        int place = subpop.Count;
        while (place > 0 && subpop[place - 1].eval.penalizedCost > indiv.eval.penalizedCost - 0.00001f) place--;
        subpop.Insert(place, myIndividual);

        // Trigger a survivor selection if the maximimum subpopulation size is exceeded
        if (subpop.Count > ParametersMgr.inst.ap.mu + ParametersMgr.inst.ap.lambda)
		    while (subpop.Count > ParametersMgr.inst.ap.mu)
			    RemoveWorstBiasedFitness(subpop);

        // Track best solution
        if (indiv.eval.isFeasible && indiv.eval.penalizedCost < bestSolutionRestart.eval.penalizedCost - 0.00001f)
        {
            bestSolutionRestart = indiv; // Copy       
            if (indiv.eval.penalizedCost < bestSolutionOverall.eval.penalizedCost - 0.00001f)
            {
                bestSolutionOverall = indiv;
                searchProgress.Add(new Tuple<float, double>(Time.realtimeSinceStartup - ParametersMgr.inst.startTime, bestSolutionOverall.eval.penalizedCost));

                StatsMgr.inst.bestCosts[CVRPMain.inst.run] = indiv.eval.penalizedCost;
                StatsMgr.inst.speeds[CVRPMain.inst.run] = GeneticMgr.inst.nbIter;
                StatsMgr.inst.times[CVRPMain.inst.run] = Time.realtimeSinceStartup - ParametersMgr.inst.startTime;

                if (CVRPMain.inst.graph)
                {
                    GraphMgr.inst.RemoveAllEdges();
                    foreach (List<int> route in indiv.chromR)
                    {
                        if (route.Count > 0)
                        {
                            Color randomColor = new Color(Random.value, Random.value, Random.value);
                            GraphMgr.inst.DrawRoute(route, randomColor);
                        }
                    }
                }
            }
            return true;
        }
        else
            return false;
    }

    void UpdateBiasedFitnesses(List<Individual> pop)
    {
        // Ranking the individuals based on their diversity contribution (decreasing order of distance)
        List<Tuple<double, int>> ranking = new List<Tuple<double, int>>();
        for (int i = 0; i < pop.Count; i++)
            ranking.Add(new Tuple<double, int>(-AverageBrokenPairsDistanceClosest(pop[i], ParametersMgr.inst.ap.nbClose), i));
        ranking.Sort();

        // Updating the biased fitness values
        if (pop.Count == 1)
            pop[0].biasedFitness = 0;
        else
        {
            for (int i = 0; i < pop.Count; i++)
            {
                float divRank = (float)i / (float)(pop.Count - 1); // Ranking from 0 to 1
                float fitRank = (float)ranking[i].Item2 / (float)(pop.Count - 1);
                if ((pop.Count <= ParametersMgr.inst.ap.nbElite)) // Elite individuals cannot be smaller than population size

                    pop[ranking[i].Item2].biasedFitness = fitRank;

                else
                    pop[ranking[i].Item2].biasedFitness = fitRank + (1.0f - (float)ParametersMgr.inst.ap.nbElite / (float)pop.Count) * divRank;
            }
        }
    }
    

    void RemoveWorstBiasedFitness(List<Individual> pop)
    {
        UpdateBiasedFitnesses(pop);
        if (pop.Count <= 1) 
        {
            Debug.Log("Eliminating the best individual: this should not occur in HGS");
            return;
        }

        Individual worstIndividual = null;
        int worstIndividualPosition = -1;
        bool isWorstIndividualClone = false;
        double worstIndividualBiasedFitness = -1e30f;

        for (int i = 1; i < pop.Count; i++)
        {
            bool isClone = (AverageBrokenPairsDistanceClosest(pop[i], 1) < 0.00001f); // A distance equal to 0 indicates that a clone exists
            if ((isClone && !isWorstIndividualClone) || (isClone == isWorstIndividualClone && pop[i].biasedFitness > worstIndividualBiasedFitness))
            {
                worstIndividualBiasedFitness = pop[i].biasedFitness;
                isWorstIndividualClone = isClone;
                worstIndividualPosition = i;
                worstIndividual = pop[i];
            }
        }

        // Removing the individual from the population
        pop.RemoveAt(worstIndividualPosition);

        // Cleaning its distances from the other individuals in the population
        foreach (Individual indiv2 in pop)
        {
            // Find the key where the list contains the worst individual
            double? keyToRemove = null;

            foreach (var kvp in indiv2.indivsPerProximity)
            {
                if (kvp.Value.Contains(worstIndividual))
                {
                    keyToRemove = kvp.Key;
                    break;
                }
            }

            if (keyToRemove.HasValue)
            {
                indiv2.indivsPerProximity.Remove(keyToRemove.Value);
            }
        }
    }

    public void Restart()
    {
        Debug.Log("----- RESET: CREATING A NEW POPULATION -----");
        feasibleSubpop.Clear();
        infeasibleSubpop.Clear();
        bestSolutionRestart = new Individual();
        bestSolutionRestart.eval.penalizedCost = 1e30f;
        bestSolutionOverall = new Individual();
        bestSolutionOverall.eval.penalizedCost = 1e30f;
        GeneratePopulation();
    }

    public void ManagePenalties()
    {
        // Setting some bounds [0.1,100000] to the penalty values for safety
        double fractionFeasibleLoad = listFeasibilityLoad.Count(x => x) / (double) listFeasibilityLoad.Count;
        if (fractionFeasibleLoad < ParametersMgr.inst.ap.targetFeasible - 0.05 && ParametersMgr.inst.penaltyCapacity < 100000)
		    ParametersMgr.inst.penaltyCapacity = Math.Min(ParametersMgr.inst.penaltyCapacity * ParametersMgr.inst.ap.penaltyIncrease, 100000);
        else if (fractionFeasibleLoad > ParametersMgr.inst.ap.targetFeasible + 0.05 && ParametersMgr.inst.penaltyCapacity > 0.1)
		    ParametersMgr.inst.penaltyCapacity = Math.Max(ParametersMgr.inst.penaltyCapacity* ParametersMgr.inst.ap.penaltyDecrease, 0.1);

        // Setting some bounds [0.1,100000] to the penalty values for safety
        double fractionFeasibleDuration = listFeasibilityDuration.Count(x => x) / (double)listFeasibilityDuration.Count;
        if (fractionFeasibleDuration < ParametersMgr.inst.ap.targetFeasible - 0.05 && ParametersMgr.inst.penaltyDuration < 100000)
		    ParametersMgr.inst.penaltyDuration = Math.Min(ParametersMgr.inst.penaltyDuration* ParametersMgr.inst.ap.penaltyIncrease, 100000);
        else if (fractionFeasibleDuration > ParametersMgr.inst.ap.targetFeasible + 0.05 && ParametersMgr.inst.penaltyDuration > 0.1)
		    ParametersMgr.inst.penaltyDuration = Math.Max(ParametersMgr.inst.penaltyDuration* ParametersMgr.inst.ap.penaltyDecrease, 0.1);

        // Update the evaluations
        for (int i = 0; i < infeasibleSubpop.Count; i++)
            infeasibleSubpop[i].eval.penalizedCost = infeasibleSubpop[i].eval.distance
            + ParametersMgr.inst.penaltyCapacity * infeasibleSubpop[i].eval.capacityExcess
            + ParametersMgr.inst.penaltyDuration * infeasibleSubpop[i].eval.durationExcess;

        // If needed, reorder the individuals in the infeasible subpopulation since the penalty values have changed (simple bubble sort for the sake of simplicity)
        for (int i = 0; i < infeasibleSubpop.Count; i++)
        {
            for (int j = 0; j < infeasibleSubpop.Count - i - 1; j++)
            {
                if (infeasibleSubpop[j].eval.penalizedCost > infeasibleSubpop[j + 1].eval.penalizedCost + 0.00001f)
                {
                    Individual indiv = infeasibleSubpop[j];
                    infeasibleSubpop[j] = infeasibleSubpop[j + 1];
                    infeasibleSubpop[j + 1] = indiv;
                }
            }
        }
    }

    public Individual GetBinaryTournament()
    {
        // Picking two individuals with uniform distribution over the union of the feasible and infeasible subpopulations
        int place1 = ParametersMgr.inst.ran.Range(0, feasibleSubpop.Count + infeasibleSubpop.Count - 1);
        int place2 = ParametersMgr.inst.ran.Range(0, feasibleSubpop.Count + infeasibleSubpop.Count - 1);

        Individual indiv1 = (place1 >= (int)feasibleSubpop.Count) ? infeasibleSubpop[place1 - feasibleSubpop.Count] : feasibleSubpop[place1];
        Individual indiv2 = (place2 >= (int)feasibleSubpop.Count) ? infeasibleSubpop[place2 - feasibleSubpop.Count] : feasibleSubpop[place2];

        // Keeping the best of the two in terms of biased fitness
        UpdateBiasedFitnesses(feasibleSubpop);
        UpdateBiasedFitnesses(infeasibleSubpop);
        if (indiv1.biasedFitness < indiv2.biasedFitness) return indiv1;
        else return indiv2;
    }

    public Individual GetBestFeasible()
    {
        if (feasibleSubpop != null && feasibleSubpop.Count != 0) return feasibleSubpop[0];
        else return null;
    }

    public Individual GetBestInfeasible()
    {
        if (infeasibleSubpop.Count != 0) return infeasibleSubpop[0];
        else return null;
    }

    public void PrintState(int nbIter, int nbIterNoImprovement)
    {
        string output = "";

        output += string.Format("It {0,6} {1,6} | T(s) {2:F2}", nbIter, nbIterNoImprovement, (Time.realtimeSinceStartup - ParametersMgr.inst.startTime));

        if (GetBestFeasible() != null) output += string.Format("\nFeas {0} {1:F2} {2:F2}", feasibleSubpop.Count, GetBestFeasible().eval.penalizedCost, GetAverageCost(feasibleSubpop));
        else output += "\nNO-FEASIBLE";

        if (GetBestInfeasible() != null) output += string.Format("\nInf {0} {1:F2} {2:F2}", infeasibleSubpop.Count, GetBestInfeasible().eval.penalizedCost, GetAverageCost(infeasibleSubpop));
        else output += "\nNO-INFEASIBLE";

        output += string.Format(
            "\nDiv {0:F2} {1:F2} \nFeas {2:F2} {3:F2} \nPen {4:F2} {5:F2}",
            GetDiversity(feasibleSubpop),
            GetDiversity(infeasibleSubpop),
            listFeasibilityLoad.Count(x => x) / (float)listFeasibilityLoad.Count,
            listFeasibilityDuration.Count(x => x) / (float)listFeasibilityDuration.Count,
            ParametersMgr.inst.penaltyCapacity,
            ParametersMgr.inst.penaltyDuration);

        if (GetBestFeasible() != null)
        {
            foreach(List<int> route in GetBestFeasible().chromR)
            {
                output += "\n" + BasicsChecking.PrintList(route);
            }
        }

        Debug.Log(output);
    }

    float BrokenPairsDistance(Individual indiv1,  Individual indiv2)
    {
        int differences = 0;
        for (int j = 1; j <= ParametersMgr.inst.nbClients; j++)
	    {
            if (indiv1.successors[j] != indiv2.successors[j] && indiv1.successors[j] != indiv2.predecessors[j]) differences++;
            if (indiv1.predecessors[j] == 0 && indiv2.predecessors[j] != 0 && indiv2.successors[j] != 0) differences++;
        }
        return (float) differences / (float) ParametersMgr.inst.nbClients;
    }

    double AverageBrokenPairsDistanceClosest(Individual indiv, int nbClosest)
    {
        double result = 0;
        int maxSize = Mathf.Min(nbClosest, indiv.indivsPerProximity.Count);

        var enumerator = indiv.indivsPerProximity.GetEnumerator();
        for (int i = 0; i < maxSize; i++)
        {
            enumerator.MoveNext();
            result += enumerator.Current.Key;
        }

        return result / maxSize;
    }

    double GetDiversity(List<Individual> pop)
    {
        double average = 0;
        int size = Mathf.Min(ParametersMgr.inst.ap.mu, pop.Count); // Only monitoring the "mu" better solutions to avoid too much noise in the measurements
	    for (int i = 0; i<size; i++) average += AverageBrokenPairsDistanceClosest(pop[i], size);
	    if (size > 0) return average / (double) size;
	    else return -1.0f;
    }

    double GetAverageCost(List<Individual> pop)
    {
        double average = 0;
        int size = Mathf.Min(ParametersMgr.inst.ap.mu, pop.Count); // Only monitoring the "mu" better solutions to avoid too much noise in the measurements
	    for (int i = 0; i<size; i++) average += pop[i].eval.penalizedCost;
	    if (size > 0) return average / (double) size;
	    else return -1.0f;
    }

    public void InitValues()
    {
        feasibleSubpop = new List<Individual>();
        infeasibleSubpop = new List<Individual>();
        listFeasibilityLoad = Enumerable.Repeat(true, ParametersMgr.inst.ap.nbIterPenaltyManagement).ToList();
        listFeasibilityDuration = Enumerable.Repeat(true, ParametersMgr.inst.ap.nbIterPenaltyManagement).ToList();
        searchProgress = new List<Tuple<float, double>>();
        bestSolutionRestart = new Individual();
        bestSolutionRestart.eval.penalizedCost = 1e30f;
        bestSolutionOverall = new Individual();
        bestSolutionOverall.eval.penalizedCost = 1e30f;

    }

    public void Init()
    {
        InitValues();
        GeneratePopulation();
    }
}
