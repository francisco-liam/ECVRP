using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using UnityEngine;
using Random = UnityEngine.Random;

public class PopulationMgr : MonoBehaviour
{
    public static PopulationMgr inst;

    public List<Individual> feasibleSubpop;            // Feasible subpopulation, kept ordered by increasing penalized cost
    public List<Individual> infeasibleSubpop;          // Infeasible subpopulation, kept ordered by increasing penalized cost
    public List<bool> listFeasibilityLoad;             // Load feasibility of recent individuals generated by LS
    public List<bool> listFeasibilityDuration;         // Duration feasibility of recent individuals generated by LS
    List<Tuple<float, float>> searchProgress;   // Keeps tracks of the time stamps of successive best solutions
    Individual bestSolutionRestart;             // Best solution found during the current restart of the algorithm
    Individual bestSolutionOverall;             // Best solution found during the complete execution of the algorithm

    private void Awake()
    {
        inst = this;
    }

    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        if(Input.GetKey(KeyCode.Space))
        {
            UpdateBiasedFitnesses(feasibleSubpop);
            UpdateBiasedFitnesses(infeasibleSubpop);
        }
    }

    public void GeneratePopulation()
    {
        Debug.Log("----- BUILDING INITIAL POPULATION");
        for(int i = 0; i < CVRPMgr.inst.ap.mu && 
            (i == 0 || CVRPMgr.inst.ap.timeLimit == 0 || Time.realtimeSinceStartup - CVRPMgr.inst.startTime < CVRPMgr.inst.ap.timeLimit); i++)
        {
            Individual randomIndiv = new Individual();
            SplitMgr.inst.GeneralSplit(randomIndiv, CVRPMgr.inst.problem.vehicles);
            LocalSearchMgr.inst.Run(randomIndiv, CVRPMgr.inst.penaltyCapacity, CVRPMgr.inst.penaltyDuration); // Repair half of the solutions in case of infeasibility
            AddIndividual(randomIndiv, true);
            if(!randomIndiv.eval.isFeasible && Random.Range(0, 2) % 2 == 0)
            {
                LocalSearchMgr.inst.Run(randomIndiv, CVRPMgr.inst.penaltyCapacity*10, CVRPMgr.inst.penaltyDuration*10);
                if (randomIndiv.eval.isFeasible) AddIndividual(randomIndiv, false);
            }
        }
    }

    public bool AddIndividual(Individual indiv, bool updateFeasible)
    {
        if (updateFeasible)
        {
            listFeasibilityLoad.Add(indiv.eval.capacityExcess < float.Epsilon);
            listFeasibilityDuration.Add(indiv.eval.durationExcess < float.Epsilon);
            listFeasibilityDuration.RemoveAt(0);
            listFeasibilityDuration.RemoveAt(0);
        }

        // Find the adequate subpopulation in relation to the individual feasibility
        List<Individual> subpop = indiv.eval.isFeasible ? feasibleSubpop : infeasibleSubpop;

        // Create a copy of the individual and updade the proximity structures calculating inter-individual distances
        Individual myIndividual = new Individual(indiv);
        foreach (Individual myIndividual2 in subpop)
        {
            float myDistance = BrokenPairsDistance(myIndividual, myIndividual2);

            if (!myIndividual2.indivsPerProximity.ContainsKey(myDistance))
                myIndividual2.indivsPerProximity[myDistance] = new List<Individual>();
            myIndividual2.indivsPerProximity[myDistance].Add(myIndividual);

            if (!myIndividual.indivsPerProximity.ContainsKey(myDistance))
                myIndividual.indivsPerProximity[myDistance] = new List<Individual>();
            myIndividual.indivsPerProximity[myDistance].Add(myIndividual2);
        }

        // Identify the correct location in the subpopulation and insert the individual
        int place = subpop.Count;
        while (place > 0 && subpop[place - 1].eval.penalizedCost > indiv.eval.penalizedCost - float.Epsilon) place--;
        subpop.Insert(place, myIndividual);

        // Trigger a survivor selection if the maximimum subpopulation size is exceeded
        if (subpop.Count > CVRPMgr.inst.ap.mu + CVRPMgr.inst.ap.lambda)
		    while (subpop.Count > CVRPMgr.inst.ap.mu)
			    RemoveWorstBiasedFitness(subpop);

        // Track best solution
        if (indiv.eval.isFeasible && indiv.eval.penalizedCost < bestSolutionRestart.eval.penalizedCost - float.Epsilon)
        {
            bestSolutionRestart = indiv; // Copy
            if (indiv.eval.penalizedCost < bestSolutionOverall.eval.penalizedCost - float.Epsilon)
            {
                bestSolutionOverall = indiv;
                searchProgress.Add(new Tuple<float, float>(Time.realtimeSinceStartup - CVRPMgr.inst.startTime, bestSolutionOverall.eval.penalizedCost));
            }
            return true;
        }
        else
            return false;
    }

    void UpdateBiasedFitnesses(List<Individual> pop)
    {
        // Ranking the individuals based on their diversity contribution (decreasing order of distance)
        List<Tuple<float, int>> ranking = new List<Tuple<float, int>>();
        for (int i = 0; i < pop.Count; i++)
            ranking.Add(new Tuple<float, int>(-AverageBrokenPairsDistanceClosest(pop[i], CVRPMgr.inst.ap.nbClose), i));
        ranking.Sort();

        // Updating the biased fitness values
        if (pop.Count == 1)
            pop[0].biasedFitness = 0;
        else
        {
            for (int i = 0; i < pop.Count; i++)
            {
                float divRank = (float)i / (float)(pop.Count - 1); // Ranking from 0 to 1
                float fitRank = (float)ranking[i].Item2 / (float)(pop.Count - 1);
                if ((pop.Count <= CVRPMgr.inst.ap.nbElite)) // Elite individuals cannot be smaller than population size

                    pop[ranking[i].Item2].biasedFitness = fitRank;

                else
                    pop[ranking[i].Item2].biasedFitness = fitRank + (1.0f - (float)CVRPMgr.inst.ap.nbElite / (float)pop.Count) * divRank;
            }
        }
    }
    

    void RemoveWorstBiasedFitness(List<Individual> pop)
    {
        UpdateBiasedFitnesses(pop);
        if (pop.Count <= 1) 
        {
            Debug.Log("Eliminating the best individual: this should not occur in HGS");
            return;
        }

        Individual worstIndividual = null;
        int worstIndividualPosition = -1;
        bool isWorstIndividualClone = false;
        float worstIndividualBiasedFitness = -1e30f;

        for (int i = 1; i < pop.Count; i++)
        {
            bool isClone = (AverageBrokenPairsDistanceClosest(pop[i], 1) < float.Epsilon); // A distance equal to 0 indicates that a clone exists
            if ((isClone && !isWorstIndividualClone) || (isClone == isWorstIndividualClone && pop[i].biasedFitness > worstIndividualBiasedFitness))
            {
                worstIndividualBiasedFitness = pop[i].biasedFitness;
                isWorstIndividualClone = isClone;
                worstIndividualPosition = i;
                worstIndividual = pop[i];
            }
        }

        // Removing the individual from the population
        pop.RemoveAt(worstIndividualPosition);

        // Cleaning its distances from the other individuals in the population
        foreach (Individual indiv2 in pop)
        {
            // Find the key where the list contains the worst individual
            float? keyToRemove = null;

            foreach (var kvp in indiv2.indivsPerProximity)
            {
                if (kvp.Value.Contains(worstIndividual))
                {
                    keyToRemove = kvp.Key;
                    break;
                }
            }

            if (keyToRemove.HasValue)
            {
                indiv2.indivsPerProximity.Remove(keyToRemove.Value);
            }
        }
    }

    public Individual GetBinaryTournament()
    {
        // Picking two individuals with uniform distribution over the union of the feasible and infeasible subpopulations
        int place1 = Random.Range(0, feasibleSubpop.Count + infeasibleSubpop.Count);
        int place2 = Random.Range(0, feasibleSubpop.Count + infeasibleSubpop.Count);

        Individual indiv1 = (place1 >= (int)feasibleSubpop.Count) ? infeasibleSubpop[place1 - feasibleSubpop.Count] : feasibleSubpop[place1];
        Individual indiv2 = (place2 >= (int)feasibleSubpop.Count) ? infeasibleSubpop[place2 - feasibleSubpop.Count] : feasibleSubpop[place2];

        // Keeping the best of the two in terms of biased fitness
        UpdateBiasedFitnesses(feasibleSubpop);
        UpdateBiasedFitnesses(infeasibleSubpop);
        if (indiv1.biasedFitness < indiv2.biasedFitness) return indiv1;
        else return indiv2;
    }

    float BrokenPairsDistance(Individual indiv1,  Individual indiv2)
    {
        int differences = 0;
        for (int j = 1; j <= CVRPMgr.inst.problem.customers; j++)
	    {
            if (indiv1.successors[j] != indiv2.successors[j] && indiv1.successors[j] != indiv2.predecessors[j]) differences++;
            if (indiv1.predecessors[j] == 0 && indiv2.predecessors[j] != 0 && indiv2.successors[j] != 0) differences++;
        }
        return (float) differences / (float) CVRPMgr.inst.problem.customers;
    }

    float AverageBrokenPairsDistanceClosest(Individual indiv, int nbClosest)
    {
        float result = 0;
        int maxSize = Mathf.Min(nbClosest, indiv.indivsPerProximity.Count);

        var enumerator = indiv.indivsPerProximity.GetEnumerator();
        for (int i = 0; i < maxSize; i++)
        {
            enumerator.MoveNext();
            result += enumerator.Current.Key;
        }

        return result / maxSize;
    }

    void InitValues()
    {
        feasibleSubpop = new List<Individual>();
        infeasibleSubpop = new List<Individual>();
        listFeasibilityLoad = Enumerable.Repeat(true, CVRPMgr.inst.ap.nbIterPenaltyManagement).ToList();
        listFeasibilityDuration = Enumerable.Repeat(true, CVRPMgr.inst.ap.nbIterPenaltyManagement).ToList();
        searchProgress = new List<Tuple<float, float>>();
        bestSolutionRestart = new Individual();
        bestSolutionOverall = new Individual();

    }

    public void Init()
    {
        InitValues();
        GeneratePopulation();
    }
}
